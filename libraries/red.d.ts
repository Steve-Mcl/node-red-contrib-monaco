declare namespace RED {
  export const util: Util;
  export type NodeStatusFill = 'red' | 'green' | 'yellow' | 'blue' | 'grey';
  export type NodeStatusShape = 'ring' | 'dot';
  export interface Error {
    stack?: string;
  }
  export interface Util {
    /**
     * Generates a psuedo-unique-random id.
     * @returns a random-ish id
     */
    generateId(): string;
    /**
     * Converts the provided argument to a String, using type-dependent
     * methods.
     *
     * @param o - the property to convert to a String
     * @returns the stringified version
     */
    ensureString(o: unknown): string;
    /**
     * Converts the provided argument to a Buffer, using type-dependent
     * methods.
     *
     * @param o - the property to convert to a Buffer
     * @returns the Buffer version
     */
    ensureBuffer(o: unknown): Buffer;
    /**
     * Safely clones a message object. This handles msg.req/msg.res objects that must
     * not be cloned.
     *
     * @param msg - the message object to clone
     * @returns the cloned message
     */
    cloneMessage<T extends NodeMessage>(msg: T): T;
    /**
     * Compares two objects, handling various JavaScript types.
     *
     * @param obj1
     * @param obj2
     * @returns whether the two objects are the same
     */
    compareObjects(obj1: object, obj2: object): boolean;
    /**
     * Parses a property expression, such as `msg.foo.bar[3]` to validate it
     * and convert it to a canonical version expressed as an Array of property
     * names.
     *
     * For example, `a["b"].c` returns `['a','b','c']`
     *
     * @param str - the property expression
     * @returns the normalised expression
     */
    normalisePropertyExpression(str: string): Array<string | number>;
    /**
     * Gets a property of a message object.
     *
     * Unlike `getObjectProperty`, this function will strip `msg.` from the
     * front of the property expression if present.
     *
     * @param msg - the message object
     * @param expr - the property expression
     * @returns the message property, or undefined if it does not exist
     */
    getMessageProperty(msg: object, expr: string): any;
    /**
     * Gets a property of an object.
     *
     * @param msg - the object
     * @param expr - the property expression
     * @returns the object property, or undefined if it does not exist
     */
    getObjectProperty(msg: object, expr: string): any;
    /**
     * Sets a property of a message object.
     *
     * Unlike `setObjectProperty`, this function will strip `msg.` from the
     * front of the property expression if present.
     *
     * @param  msg           - the message object
     * @param  prop          - the property expression
     * @param  value         - the value to set
     * @param  createMissing - whether to create missing parent properties
     */
    setMessageProperty(msg: object, prop: string, value: any, createMissing?: boolean): boolean;
    /**
     * Sets a property of an object.
     *
     * @param  msg           - the object
     * @param  prop          - the property expression
     * @param  value         - the value to set
     * @param  createMissing - whether to create missing parent properties
     */
    setObjectProperty(msg: object, prop: string, value: any, createMissing?: boolean): boolean;
    /**
     * Get value of environment variable.
     * @param node - accessing node
     * @param name - name of variable
     * @returns value of env var
     */
    getSetting(node: Node, name: string): string;
    /**
     * Checks if a String contains any Environment Variable specifiers and returns
     * it with their values substituted in place.
     *
     * For example, if the env var `WHO` is set to `Joe`, the string `Hello ${WHO}!`
     * will return `Hello Joe!`.
     * @param value - the string to parse
     * @param node - the node evaluating the property
     * @returns The parsed string
     */
    evaluateEnvProperty(value: string, node: Node): string;
    /**
     * Parses a context property string, as generated by the TypedInput, to extract
     * the store name if present.
     *
     * For example, `#:(file)::foo` results in ` { store: "file", key: "foo" }`.
     *
     * @param key - the context property string to parse
     * @returns The parsed property
     */
    parseContextStore(key: string): { store?: string; key: string };
    /**
     * Evaluates a property value according to its type.
     *
     * @param   value    - the raw value
     * @param   type     - the type of the value
     * @param   node     - the node evaluating the property
     * @param   msg      - the message object to evaluate against
     * @param   callback - (optional) called when the property is evaluated
     * @returns The evaluted property, if no `callback` is provided
     */
    evaluateNodeProperty(value: string, type: string, node: Node, msg: object): any;
    evaluateNodeProperty(
      value: string,
      type: string,
      node: Node,
      msg: object,
      callback: (err: Error | null, result: any) => void,
    ): void;
    /**
     * Prepares a JSONata expression for evaluation.
     * This attaches Node-RED specific functions to the expression.
     *
     * @param value - the JSONata expression
     * @param node  - the node evaluating the property
     * @returns The JSONata expression that can be evaluated
     */
    prepareJSONataExpression(value: string, node: Node): Jsonata.Expression;
    /**
     * Evaluates a JSONata expression.
     * The expression must have been prepared with `prepareJSONataExpression`
     * before passing to this function.
     *
     * @param   expr     - the prepared JSONata expression
     * @param   msg      - the message object to evaluate against
     * @param   callback - (optional) called when the expression is evaluated
     * @returns If no callback was provided, the result of the expression
     */
    evaluateJSONataExpression(expr: Jsonata.Expression, msg: object): any;
    evaluateJSONataExpression(
      expr: Jsonata.Expression,
      msg: object,
      callback: (err: Error | null, resp: any) => void,
    ): void;
    /**
     * Normalise a node type name to camel case.
     *
     * For example: `a-random node type` will normalise to `aRandomNodeType`
     *
     * @param name - the node type
     * @returns The normalised name
     */
    normaliseNodeTypeName(name: string): string;
    /**
     * Encode an object to JSON without losing information about non-JSON types
     * such as Buffer and Function.
     *
     * *This function is closely tied to its reverse within the editor*
     *
     * @param msg
     * @param opts
     * @returns the encoded object
     */
    encodeObject(msg: { msg: any }, opts?: { maxLength?: number }): { format: string; msg: string };
  }
  export interface NodeMessage {
    _msgid?: string;
    topic?: string;
    payload?: Record<string, any>;
  }
  export interface Node {
    id: string;
    type: string;
    z: string;
    name?: string;
    /**
     * Send a message to the nodes wired.
     * @param msg A message or array of messages to send
     */
    send(msg?: NodeMessage | NodeMessage[]): void;
    /**
     * Log an INFO level message
     * @param msg
     */
    log(msg: any): void;
    /**
     * Log a WARN level message
     * @param msg
     */
    warn(msg: any): void;
    /**
     * Log an ERROR level message
     * @param logMessage
     * @param msg
     */
    error(logMessage: any, msg?: NodeMessage): void;
    /**
     * Log an DEBUG level message
     * @param msg
     */
    debug(msg: any): void;
    /**
     * The done function must be called when it has finished handling the message.
     * It takes one optional argument, an error object
     * if the node has failed to handle the message for some reason.
     * @param error
     */
    done(error?: Error): void;
    /**
     * Log an TRACE level message
     * @param msg
     */
    trace(msg: any): void;
    /**
     * Set the node's status object
     *
     * status: { fill:"red|green", shape:"dot|ring", text:"blah" }
     * or
     * status: "simple text status"
     */
    status(status: string | NodeStatus): void;
  }
  export interface NodeStatus {
    fill?: NodeStatusFill;
    shape?: NodeStatusShape;
    text?: string;
  }
  export interface ContextData {
    /**
     * Get a value from context
     * @param key
     * @param storeName - store name when multiple context stores are used
     */
    get(key: string, storeName?: string): unknown;
    /**
     * Get a value from context asynchronously
     */
    get(key: string, cb: (err: Error, value: unknown) => void): void;
    /**
     * Get multiple values from context
     * @param keys
     * @param storeName - store name when multiple context stores are used
     */
    get(keys: string[], storeName?: string): unknown[];
    /**
     * Get multiple values from context asynchronously
     */
    get(keys: string[], cb: (err: Error, value: unknown[]) => void): void;

    /**
     * Get a value from context asynchronously, when multiple context stores are used
     */
    get(key: string, storeName: string | undefined, cb: (err: Error, value: unknown) => void): void;
    /**
     * Get multiple values from context asynchronously, when multiple context stores are used
     */
    get(
      keys: string[],
      storeName: string | undefined,
      cb: (err: Error, value: unknown[]) => void,
    ): void;

    /**
     * Set a value in context
     * @param key
     * @param value
     * @param cb - callback for async calls
     */
    set(key: string, value: unknown, cb?: (err: Error) => void): void;
    /**
     * Set multiple values in context
     * @param keys
     * @param values
     * @param cb - callback for async calls
     */
    set(keys: string[], values: unknown[], cb?: (err: Error) => void): void;

    /**
     * Set a value in context, when multiple context stores are used
     * @param key
     * @param value
     * @param storeName
     * @param cb - callback for async calls
     */
    set(
      key: string,
      value: unknown,
      storeName: string | undefined,
      cb?: (err: Error) => void,
    ): void;
    /**
     * Set multiple values in context, when multiple context stores are used
     * @param keys
     * @param values
     * @param storeName
     * @param cb - callback for async calls
     */
    set(
      keys: string[],
      values: unknown[],
      storeName: string | undefined,
      cb?: (err: Error) => void,
    ): void;

    /**
     * Returns a list of all node-scoped context property keys
     * @param storeName - store name when multiple context stores are used
     */
    keys(storeName?: string): string[];
    /**
     * Returns a list of all node-scoped context property keys asynchronously
     */
    keys(cb: (err: Error, value: unknown[]) => void): void;
    /**
     * Returns a list of all node-scoped context property keys asynchronously, when multiple context stores are used
     */
    keys(storeName: string | undefined, cb: (err: Error, value: unknown[]) => void): void;
  }
}

declare namespace Jsonata {
  export interface ExprNode {
    type: string;
    value: any;
    position: number;
  }
  export interface JsonataError extends Error {
    code: string;
    position: number;
    token: string;
  }
  export interface Environment {
    bind(name: string, value: any): void;
    lookup(name: string): any;
    readonly timestamp: Date;
    readonly async: boolean;
  }
  export interface Focus {
    readonly environment: Environment;
    readonly input: any;
  }
  export interface Expression {
    evaluate(input: any, bindings?: Record<string, any>): any;
    evaluate(
      input: any,
      bindings: Record<string, any> | undefined,
      callback: (err: JsonataError, resp: any) => void,
    ): void;
    assign(name: string, value: any): void;
    registerFunction(
      name: string,
      implementation: (this: Focus, ...args: any[]) => any,
      signature?: string,
    ): void;
    ast(): ExprNode;
  }
}
